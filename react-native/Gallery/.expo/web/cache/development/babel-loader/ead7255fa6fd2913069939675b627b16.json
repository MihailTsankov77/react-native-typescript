{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport { useInputFormat, useInputFormatter, useRangeChecker } from \"./dateUtils\";\nimport * as React from 'react';\nimport { getTranslation } from 'react-native-paper-dates';\nexport default function useDateInput(_ref) {\n  var locale = _ref.locale,\n      value = _ref.value,\n      validRange = _ref.validRange,\n      inputMode = _ref.inputMode,\n      onChange = _ref.onChange;\n\n  var _useRangeChecker = useRangeChecker(validRange),\n      isDisabled = _useRangeChecker.isDisabled,\n      isWithinValidRange = _useRangeChecker.isWithinValidRange,\n      validStart = _useRangeChecker.validStart,\n      validEnd = _useRangeChecker.validEnd;\n\n  var _React$useState = React.useState(null),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      error = _React$useState2[0],\n      setError = _React$useState2[1];\n\n  var formatter = useInputFormatter({\n    locale: locale\n  });\n  var inputFormat = useInputFormat({\n    formatter: formatter,\n    locale: locale\n  });\n  var formattedValue = value !== null ? formatter.format(value) : '';\n\n  var onChangeText = function onChangeText(date) {\n    var dayIndex = inputFormat.indexOf('DD');\n    var monthIndex = inputFormat.indexOf('MM');\n    var yearIndex = locale === 'pt' ? inputFormat.indexOf('AAAA') : inputFormat.indexOf('YYYY');\n    var day = Number(date.slice(dayIndex, dayIndex + 2));\n    var year = Number(date.slice(yearIndex, yearIndex + 4));\n    var month = Number(date.slice(monthIndex, monthIndex + 2));\n\n    if (Number.isNaN(day) || Number.isNaN(year) || Number.isNaN(month)) {\n      setError(getTranslation(locale, 'notAccordingToDateFormat', function () {\n        return 'notAccordingToDateFormat';\n      })(inputFormat));\n      return;\n    }\n\n    var finalDate = inputMode === 'end' ? new Date(year, month - 1, day, 23, 59, 59) : new Date(year, month - 1, day);\n\n    if (isDisabled(finalDate)) {\n      setError(getTranslation(locale, 'dateIsDisabled'));\n      return;\n    }\n\n    if (!isWithinValidRange(finalDate)) {\n      var errors = validStart && validEnd ? [\"\" + getTranslation(locale, 'mustBeBetween', function () {\n        return 'mustBeBetween';\n      })(formatter.format(validStart), formatter.format(validEnd))] : [validStart ? getTranslation(locale, 'mustBeHigherThan', function () {\n        return 'mustBeHigherThan';\n      })(formatter.format(validStart)) : '', validEnd ? getTranslation(locale, 'mustBeLowerThan', function () {\n        return 'mustBeLowerThan';\n      })(formatter.format(validEnd)) : ''];\n      setError(errors.filter(function (n) {\n        return n;\n      }).join(' '));\n      return;\n    }\n\n    setError(null);\n\n    if (inputMode === 'end') {\n      onChange(finalDate);\n    } else {\n      onChange(finalDate);\n    }\n  };\n\n  return {\n    onChange: onChange,\n    error: error,\n    formattedValue: formattedValue,\n    onChangeText: onChangeText,\n    inputFormat: inputFormat\n  };\n}","map":{"version":3,"mappings":"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","names":["useInputFormat","useInputFormatter","useRangeChecker","React","getTranslation","useDateInput","locale","value","validRange","inputMode","onChange","isDisabled","isWithinValidRange","validStart","validEnd","useState","error","setError","formatter","inputFormat","formattedValue","format","onChangeText","date","dayIndex","indexOf","monthIndex","yearIndex","day","Number","slice","year","month","isNaN","finalDate","Date","errors","filter","n","join"],"sources":["inputUtils.ts"],"sourcesContent":["import { useInputFormat, useInputFormatter, useRangeChecker } from './dateUtils'\nimport * as React from 'react'\nimport type { ValidRangeType } from './Calendar'\nimport { getTranslation } from 'react-native-paper-dates'\n\nexport default function useDateInput({\n  locale,\n  value,\n  validRange,\n  inputMode,\n  onChange,\n}: {\n  onChange: (d: Date) => void\n  locale: undefined | string\n  value: Date | undefined\n  validRange: ValidRangeType | undefined\n  inputMode: 'start' | 'end'\n}) {\n  const { isDisabled, isWithinValidRange, validStart, validEnd } =\n    useRangeChecker(validRange)\n  const [error, setError] = React.useState<null | string>(null)\n  const formatter = useInputFormatter({ locale })\n  const inputFormat = useInputFormat({ formatter, locale })\n  const formattedValue = value !== null ? formatter.format(value) : '';\n  const onChangeText = (date: string) => {\n    const dayIndex = inputFormat.indexOf('DD')\n    const monthIndex = inputFormat.indexOf('MM')\n    const yearIndex =\n      locale === 'pt'\n        ? inputFormat.indexOf('AAAA')\n        : inputFormat.indexOf('YYYY')\n\n    const day = Number(date.slice(dayIndex, dayIndex + 2))\n    const year = Number(date.slice(yearIndex, yearIndex + 4))\n    const month = Number(date.slice(monthIndex, monthIndex + 2))\n\n    if (Number.isNaN(day) || Number.isNaN(year) || Number.isNaN(month)) {\n      setError(\n        getTranslation(\n          locale,\n          'notAccordingToDateFormat',\n          () => 'notAccordingToDateFormat'\n        )(inputFormat)\n      )\n      return\n    }\n\n    const finalDate =\n      inputMode === 'end'\n        ? new Date(year, month - 1, day, 23, 59, 59)\n        : new Date(year, month - 1, day)\n\n    if (isDisabled(finalDate)) {\n      setError(getTranslation(locale, 'dateIsDisabled'))\n      return\n    }\n    if (!isWithinValidRange(finalDate)) {\n      let errors =\n        validStart && validEnd\n          ? [\n              `${getTranslation(\n                locale,\n                'mustBeBetween',\n                () => 'mustBeBetween'\n              )(formatter.format(validStart), formatter.format(validEnd))}`,\n            ]\n          : [\n              validStart\n                ? getTranslation(\n                    locale,\n                    'mustBeHigherThan',\n                    () => 'mustBeHigherThan'\n                  )(formatter.format(validStart))\n                : '',\n              validEnd\n                ? getTranslation(\n                    locale,\n                    'mustBeLowerThan',\n                    () => 'mustBeLowerThan'\n                  )(formatter.format(validEnd))\n                : '',\n            ]\n      setError(errors.filter((n) => n).join(' '))\n      return\n    }\n\n    setError(null)\n    if (inputMode === 'end') {\n      onChange(finalDate)\n    } else {\n      onChange(finalDate)\n    }\n  }\n  return {\n    onChange,\n    error,\n    formattedValue,\n    onChangeText,\n    inputFormat,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}